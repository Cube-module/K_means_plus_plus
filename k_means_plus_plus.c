#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <float.h> // на всякий случай вдруг там будут очень страшные числа (DBL_MAX максимальное значение для флот уже доступно)

int max_clust = 300; // макс количество кластеров которое могу закинуть, если брать больше то все будет долго, но постараюсь изменить логику

double min_x = DBL_MAX, max_x = -DBL_MAX, min_y = DBL_MAX, max_y = -DBL_MAX;; // нужны для поиска диапозона координат

double epsilon = 1; // переменная обозначающая граничное значение между координатами старых координат и новых

double locot = 0.1; // переменная отвечающая за, то насколько пологим становится график плотности при разных количествах кластеров

// структура для хранения координат точки и к какому кластеру относится
typedef struct { 
    double x;
    double y;
    int kl_id;
} Point;

// структура для хранения координат кластера
typedef struct {
    double x;
    double y;
    int number; // имя или номер кластера
} Cluster;

// функция инициализирующая новый кластер координатами которые мы получили  (index)
void smart_loc(Cluster* clusters,Point* point, int k, int c, int index){

    for (int i=c; i<k; i++)
    {
        clusters[i].number=i+1; // пишем название кластера
        clusters[i].x=point[index].x; // присваеваем новому кластеру координаты выбранной точки
        clusters[i].y=point[index].y;
    }
}


// функция для задавания рандомного кластера в любой точке (но по умному)
void randome_firs(Cluster* clusters,Point* point, int kol){

    int loc = rand()%kol; // рандомная точка (в массиве от 0 до kol)
    
    double x = point[loc].x; //  получаем координаты этой точки по x
    double y = point[loc].y; // 
    
    clusters[0].x = x;  // присваевам координаты точки для первого кластера
    clusters[0].y = y; // присваевам координаты точки для первого кластера
    clusters[0].number = 1; // записываем имя для первого кластера 
}

// функция евклидова растояния между точками
double evklid_distance(double x, double y, double x1, double y1){  // по координатам возвращает растояние между точками
    double a = sqrt((x1-x)*(x1-x)+(y1-y)*(y1-y));       // буквально просто теорема пифагора но на векторах

    return a;
}        

// функция для евклидова пространства кастомная специально для wcss
double evklid_distance_wcss(double x, double y, double x1, double y1){  // по координатам возвращает растояние между точками
    double a = ((x1-x)*(x1-x)+(y1-y)*(y1-y));       // без корня для лучшей видимости, где перелом у графика с плотностью на количество кластеров

    return a;
}   

// функция увеличения масива
Cluster* uvel2(Cluster* arr, int len){

    Cluster* arr1 = realloc(arr, len*sizeof(Cluster));

    return (arr1);
}

// функция увеличения масива
Point* uvel(Point* arr, int len){

    Point* arr1 = realloc(arr, len*sizeof(Point));

    return (arr1);
}

// функция увеличения масива типа double
double* uvel3(double* arr, int len){

    double* arr1 = realloc(arr, len*sizeof(double));

    return (arr1);
}

// функция плотности для кластера wcss (тоесть ищет плотность кластера) сумма растояний от точек до их кластера
double Wcss(Cluster* cluster,Point* point ,int name_clust ,int kol){

    double sum = 0; // переменная для сохранения всей суммы растояний от точки до кластера в квадрате
    for(int i=0; i<kol; i++)
    {
        if(name_clust == point[i].kl_id){
            sum+= evklid_distance_wcss(cluster[name_clust-1].x, cluster[name_clust-1].y, point[i].x, point[i].y); // находим сумму растояний от точек до кластера
        }
    }

    return sum;
}


// функция для распределения по кластерам
void sort(Point* point, Cluster* cluster, int k, int kol){

    for (int i=0; i<kol; i++) // проходим все точки
    {
        double min_dist =DBL_MAX; // нужно для поиска минимального растояния

        int nuber; // переменная хранящая имя кластера

        for(int j=0; j<k;j++) // проходим все кластеры
        {
            double dist = evklid_distance(cluster[j].x, cluster[j].y, point[i].x, point[i].y); // ищем растояние от кластера до точки

            if(dist<min_dist){ // если растояние меньше чем нынешнее меньшее растояние то мы его перезаписываем и сохраняем имя кластера 
                min_dist=dist;
                nuber = j+1; // имя кластера (так как кластер с номером 1 лежит по 0 индексу)
            }
           
        }

        point[i].kl_id = nuber; // присваеаем точку к кластеру до которого меньшее растояние
    }

}


    // заменяет координаты кластера на средние, центрелизует кластеры                                                                                                                              (вообще так как я эту хуйню в цикле только юзаю то можно отсюда еще передовать значения предыдущих значений)
void average(Point* point,Cluster* cluster, int kol, int name){ // масив точек и сколько их и для какого кластера ищем

    double sum_x =0; // сумма координат по x
    double sum_y =0; // сумма координат по y
    int poin = 0; // счетчик количества принадлеж одному кластеру

    for(int i=0; i<kol; i++) // проходим все точки 
    {
        // если встречается имя такое же как заданное, то сумируем координаты
        if (point[i].kl_id == name){
            sum_x+=point[i].x; // сумма всех координат по х кокого-то кластера
            sum_y+=point[i].y; 
            poin++;//увелич счетчик точек
        }
    }

    double aver_x = 0; // усредненные координаты 
    double aver_y = 0;

    if (poin > 0)
    {
        aver_x = sum_x/poin; // находим средднее сначение меж координат для кластера
        aver_y = sum_y/poin;
    }
    else
    {
        aver_x = 0;
        aver_y = 0;
    }

    cluster[name-1].x=aver_x; // инициализируем (перемещаем) кластеры в серединные координаты между точек
    cluster[name-1].y=aver_y;
}

// функция для нахождения вероятности для точки (теперь она возвращает индекс точки в которой заспавним кластер)
int something(Point* point, Cluster* cluster, int kol, int k){

    double* arr = malloc(kol*sizeof(double)); // массив для растояний точекж

    double rast; // растояние в квадрате
    double sum=0; // сумма растояний в квадрате

    for (int j=0; j<kol; j++) // цикл в котором я буду находить все нужное для вероятности
    {
        double min_dist =DBL_MAX; // нужно для поиска минимального растояния

        for(int i=0; i<k; i++)
        {
            double dist = evklid_distance(cluster[i].x, cluster[i].y, point[j].x, point[j].y); // ищем растояние от кластера до точки

            if(dist<min_dist ){ // если растояние меньше чем нынешнее меньшее растояние то мы его перезаписываем и сохраняем имя кластера и при этом координаты кластера не совпадают с координатами точки
                min_dist=dist; //таким образом в конце мы получим растояние до ближ кластера
            }
        }

        if (min_dist == 0) { // если у нас оно равно 0, то в этой точке стоит кластер
            arr[j] = 0;  // Эту точку не трогаем, вероятность = 0
        }
        else
        {
            rast= min_dist*min_dist; // нашел растояние до ближайшего кластера в квадрате чтобы лучше были различия

            arr[j] = rast; // сохраняю растояния чтобы потом посчитать проценты

            sum+=rast; // такая формула у r-means++ растояние точки до кластера / на общее растояние от точек до их ближ кластеров
        }
    }

    // Генерируем случайное число от 0.0 до 1.0
    double r = (double)rand() / RAND_MAX; // какое-то рандомное значение 

    // Выбор точки по вероятностям
    double cumulative = 0.0;

    for (int i=0; i<kol; i++) // цикл в котором я буду заносить вероятности в масив для каждой точки
    {
        arr[i] = arr[i]/sum; // получил вероятность для каждой точки (где макс знач 1 тоесть 100%)

        cumulative += arr[i]; 

        if (r <= cumulative) { // ну как-то по идее работает
            // выбрана точка с индексом i

            free(arr);
            return i;
        }
    }

    free(arr);
    // 4. На случай если из-за округления не сработал return в цикле:
    return kol - 1; // на самом деле это просто проверка на всякий пожарный, потому что невозможно чтобы у нас return с верху не сработал
}

// // функция для нахождения среднего растояни(я еблан мне же координаты нужны)
// double average(double* arr, int kolich){

//     double sum = 0;
//     double res=0;

//     for (int i=0; i<kolich; i++)
//     {
//         sum+= arr[i];
//     }

//     res = sum/kolich;

//     return kolich;
// }

int main()
{
    FILE *file = fopen("data.txt", "r");
    freopen("output.txt", "w", stdout);

    srand(time(NULL));  // ← ставь сид только ОДИН РАЗ за запуск (что-то для рандома, чтобы рандом был всегда разный)

    double point_x, point_y; // координаты точек

    int len = 200; // начальный размер масива структур(точек)
    int kol = 0; // сколько на самом деле записано точек

    Point* point = malloc(len*sizeof(Point)); // выделили память для масива

    double x,y; // для считки координат (затычки)

    // если считали 2 значения в строке то все норм иначе ошибка
    while (fscanf(file, "%lf %lf", &x, &y) == 2)
    {
        if(kol>=len) // если настоящее кол точек больше размера масива то увеличиваем масив 
        {
            len*=2; // увеличиваем размер в 2 раза

            point = uvel(point, len); // увеличиваем сам масив и передаем адресс на начало нового масива
        }

        // здесь очевидно что так мы ищем диапозон точек
        if (x<min_x){
            min_x = x;
        }
        if (x>max_x){
            max_x = x;
        }
        if (y<min_y){
            min_y = y;
        }
        if (y>max_y){
            max_y = y;
        }

        point[kol].x=x; // записываем координату х
        point[kol].y=y; // записываем координату y
        point[kol].kl_id =1; // присваеваем все точки к первому кластеру (немного проебался с присвоением к первому кластеру если у нас много кластеров, то вообще присвоение должно зависеть от растояния к кластеру, кластеры задаются ниже, следовательно присвоение вероятно нужно как отдельный масив вынести в глобал)

        kol++; // увеличиваем счетчик кол записанных точек на 1 (не забывать у нас в конце считки все точек kol будет на 1 больше чем нужно)
    }


    double range; // кастомная подборка диапозона под epsilon;

    if ((max_x - min_x) > (max_y - min_y)) { // выбираю максимальный разброс между осями x и y чтобы понять где разброс больше
        range = max_x - min_x; // так как если у x разброс больше то логичней смотреть как будет перемещаться кластер с каким сдвигом именно по x
    } else {
        range = max_y - min_y;
    }

    if (range > 10000) {  
        range = 10000;  // типа "не хочу, чтобы epsilon вырос слишком сильно"
    }
    
    epsilon = 0.001 * range;

    //printf("Read %d points from fail \n\n", kol);

    int k = 1; // тип 1 кластера (количество кластеров, в будущем попробую wcss реализовать)

    Cluster *clusters = malloc(k*sizeof(Cluster)); // выдел память под масив кластеров

    randome_firs(clusters,point, kol); // задали рандомно координаты для кластеров, в данной реал задаем только первый кластер рандомно

    sort(point, clusters, k, kol); // распредилили первый раз точки между кластерами

    double* old_x = malloc(k * sizeof(double)); // сохраняем старые результаты кластеров для будущего счета растояний от нового положения до старого
    double* old_y = malloc(k * sizeof(double));

    int max_iterations = 1000; // ну для того чтобы если эпсилон оказалась слишком маленькой, чтобы можно было остановить процесс сдвига
    int iterations = 0; // счетчик сколько раз мы уже сдвинули

    double range_present=0; // нынешняя плотность кластеров

    double range_past=0; // прошлая плотность кластеров

    int size_arr=k; // нынешний размер массива кластеров

    // double aver_range=0; // минимальная плотность при определенном количестве кластеров, минимальное потому что правильней будет смотреть по самому неудачному кластеру плотность точек, тоесть кластеру у которого плотность будет минимальной

    double razn=DBL_MAX; // разница между прошлым значением по графику плотности на количество с нынешним

    // int count =0; // счетчик итераций внешнего цикла

    while (razn>locot && k <= 100) // если плотность точек в кластере меньше чем определенный спад по графику то мы останавливаем цикл
    {

        range_past = range_present; // сохраняем прошлую плотность кластеров
        range_present = 0; // обнуляем сумму

        if(k>=size_arr){ // если нынешний размер массива кластеров меньше чем само колличество кластеров, то мы увеличиваем масив
            size_arr*=3; // увеличиваем размер в 3 раза
            clusters = uvel2(clusters, size_arr); // функция для увеличения размера массива
            old_x = uvel3(old_x, size_arr); // функция для увеличения размера массива
            old_y = uvel3(old_y, size_arr);
        }

        int index = something(point, clusters, kol, k); // получаем индекс точки в который создадим новый кластер

        smart_loc(clusters, point, k, k-1, index); // задали координаты для кластера в выбранной нами точке по индексу (создаю и инициализирую новые кластеры)
        sort(point, clusters, k, kol);  // распредилили первый раз точки между кластерами (ну не первый, а создал новые кластеры и теперь надо для них точки найти
        

        double j=DBL_MAX;;// для поиска максимального значения чтобы проверить растояния, а написал выше чтобы мог занести его в wile в условие

        iterations = 0; // обнуляем счетчик

        while (j > epsilon && iterations < max_iterations) // так проверка что растояния будут почти не изменятся
        {
            j = 0; // нужно на каждой итерации перезаписывать его чтобы получить самое максимальное растояние меж кластерами в нынешней итерации

            for (int i=0;i<k;i++) // делаю к раз так как мой код кусок неоптемизированного г
            {
                old_x[i]=clusters[i].x;// сохраняем старые значения по x 
                old_y[i]=clusters[i].y;

                average(point, clusters, kol, i+1); // потом перемещаю кластер в центр меж точками (здесь я задаю новые значения для clusters[i].x, clusters[i].y)

                double ev_r = evklid_distance(clusters[i].x, clusters[i].y, old_x[i], old_y[i]); // считаем растояние от старой локации кластера до новой

                if (ev_r>j){ // если растояние между старым и новыми координатами кл больше чем старое большее растояни
                    j = ev_r; // записываем максимальное растояние, чтобы понимать когда самый плохой кластер тоже почти не будет двигаться (разумно смотреть за самым неудачным кластером)
                }

            }

            sort(point, clusters, k, kol); // и снова прощитываю какие точки входят в кластер
            iterations++;
        }

        for (int i=0; i<k; i++) // вынес чтобы посчитать wcss уже для централизованных кластеров
        {
            range_present += Wcss(clusters, point, i+1, kol); // находим сумму плотности кластеров
        }

        razn = fabs(range_present - range_past); // находим разницу между прошлым значением плотности и настоящем по модулю, чтобы все было хорошо и мы не получили отрицательного рез. это мы нашли дельту

        if (range_past == 0) // если мы смотрим первый кластер, то у него прошлый wcss не определен и поэтому делить нельзя
            razn = razn/razn; // теперь находим в процентных соотношениях (получаем 1 максимальный разброс)
        
        else
        {
            razn = razn/range_past; // а вот теперь нормальное соотношение получаем, тоесть дельта / на какойто свой член это абсолютное изменение 
        }

        //printf("Razn %lf %d\n\n", razn, k);

        k++; // увеличиваем количество кластеров

        //count++;
    }

    printf("%d\n", k-1); // количество кластеров

    // вывод координат кластеров
    for (int i = 0; i < k -1; i++){ 

        printf("%f %f\n", clusters[i].x, clusters[i].y);
    }

    printf("%d\n", kol); // количество точек

    // вывод координат точек и их принадлежность кластерам
    for (int i = 0; i < kol; i++) {
        printf(" %f %f %d\n", point[i].x, point[i].y, point[i].kl_id);
    }


    //     // Вывод центров кластеров:
    // printf("final lacation clusters:\n\n");
    // for (int i = 0; i < k -1; i++) {
    //     printf("cluster %d: x = %f, y = %f\n", clusters[i].number, clusters[i].x, clusters[i].y);
    // }

    //printf("\nCount Clusters %d\n\n", k-1);

    // // Вывод точек и их кластеров:
    // printf("\nPoint linkeds with clusters:\n\n");
    // for (int i = 0; i < kol; i++) {
    //     printf("point %d: x = %f, y = %f, cluster = %d\n", i + 1, point[i].x, point[i].y, point[i].kl_id);
    // }


    fclose(file);  // ← Закрываем файл (обязательно)

    free(old_x);
    free(old_y);
    free(point);
    free(clusters);

    return 0;
}


